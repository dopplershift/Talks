\documentclass[twocolumn]{article}

\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage{listings,bera}
\usepackage{color}
\usepackage{authblk}
\usepackage{times}

\setlength{\affilsep}{0.2em}
\title{Porting Radar Simulation Software to Python: A Case Study in the Benefits of Python}
\author{Ryan May}
\affil{Enterprise Electronics Corporation\\Norman, OK}
\date{}

%Python is known for having “batteries included”: a feature-filled standard
%library which reduces development effort for many common tasks, such as logging,
%configuration files, and command line parsing. The utilization of this standard
%library allows the addition of features to software while adding little
%additional code, or even reducing the amount of code for existing software.
%Also, by virtue of its dynamic nature and powerful built-in data structures,
%Python is able to provide a drastically simpler interface for reading NetCDF
%datasets compared to the standard interfaces in languages like C or FORTRAN.
%Python's concept of modules additionally facilitates the creation of small,
%reusable software components, which promotes code reuse. These qualities reduce
%the volume of code that must be developed and maintained, which accelerates the
%development cycle. The porting of a software radar simulator from pure C to a
%mixture of C and Python is used as a case study in the benefits moving software
%to Python.

\begin{document}
\maketitle

\definecolor{keywords}{RGB}{255,0,90}
\definecolor{comments}{RGB}{29,147,48}
\lstset{ %
language=Python,                % choose the language of the code
basicstyle=\ttfamily\scriptsize, % the size of the fonts that are used for the code
%numbers=left,                   % where to put the line-numbers
%numberstyle=\scriptsize,        % the size of the fonts that are used for the line-numbers
%stepnumber=1,                   % the step between two line-numbers. If it's 1 each line
                                % will be numbered
%numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},   % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,                   % adds a frame around the code
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                % also try caption instead of title
escapeinside={\%*}{*)},         % if you want to add a comment within your code
morekeywords={*,...}            % if you want to add more keywords to the set
keywordstyle=\color{keywords},
commentstyle=\color{comments}\emph,
linewidth=240pt
}


\section{Introduction}
Python, as a dynamic programming language, is frequently used as a "glue" language--the reference
being that it is used to glue together different parts of existing software. As a dynamic language,
development time tends to be very quick, at a cost of run-time performance. However, for much of
the code that is written, run-time performance is unimportant, so rapid devlopment can produce
large gains, especially in a research setting, where code turnover is frequent. Part of this utility
also comes from Python's feature-filled standard library, which helps a developer find needed
functionality without spending time searching for options.



As a case study in using Python, this work will examine the process of porting an existing
radar simulation software package from C to Python.  Various Python modules used in the
porting process and their impacts on the size, and more imporantly, functionality, of the
code base will be discussed.

\section{Background}
The software under study here is a package for simulating weather radar data using
numerical simulation output as the source for the atmosphere being simulated. In addition,
the simulator relies on a set of configuration data to control the radar hardware
characteristics as well as the operating parameters. The original code base was in C
and had been heavily optimized to optimize run-time performance, with a single simulation
taking several hours on a single processor machine.

Two separate changes in the needs of the software were the motivation behind the porting
of the software to Python. The first was that there was a desire to begin using the
emulator in a classroom setting. Classroom use by students required a large amount
of ease of use so as not to be a support burden.  To support this role, it was
recognized that the terminal interactivity (commandline invocation and the output
to the user) and the configuration file format would need to be improved. The second
driving requirement was the need to upgrade the code to support simulation of
dual-polarimetric radars. Part of this required  incorprating code for more
sophisticated scattering models. Also, the code needed to be able to use a variety of different scattering
models--this is needed to examine the differences that result from different approximations.
Generating simulated dual-polarimetric data also required changes to the I/O
sections of the code to read in new parameters as well as write out new generated
fields. A major consideration was the simplicity with which NetCDF files (the 
format used by the simulator) can be manipulated using Python.
All of these changes were constrained to what will be referred to as the "front-end". The
heavily optimized computational core (the "backend") of the simulator did not require significant
changes, and thus it was desired to keep it for the most part unchanged.

The author's recent (at the time) experience with Python in other domains gave
indications that Python was a promising choice for this additional development.
Adding to this was the fact that the author had already created a flexible Python
module for performing a variety of scattering calculations. Pupynere (or any
of the many other Python NetCDF libraries) provided a clear and simple path
for upgrading the I/O section of the code. Python's standard
library was the final tipping point for deciding to port to Python. Since the
library contained modules for configuration file parsing, command line parsing,
and logging, the usability improvements could be obtained with no need to search
for reliable libraries to serve these purposes. The Python standard library also
contains the ctypes module, which served as a straightforward (and included) way
to join the new Python front-end to the C-based backend.


\section{Standard Library}
In addition to language syntax and features that enable rapid development, part of 
rapid development comes from Python's feature-filled standard library. This leads
many Python developers to refer to Python as having "batteries included." The standard
library gives developers a starting point to look for a given set of functionality: 
running external processes, working files and paths, regular expressions, etc. In addition
to the benefit as a starting point, which should not be underestimated, the standard
library reduces complications from software dependencies. The modules in the standard
library can be relied upon to be present and don't need to be tested for and suggested
for installation if necessary. In this work, we examine specifically the use of
standard library modules for: command line parsing, configuration files, and message logging.


\subsection{Why is the Standard Library Important?}
  \begin{itemize}
    \item Libraries you can count on with every installation -> minimal dependency headaches
    \item Starting point for finding solid libraries to handle given tasks
    \item Ones used in this code:
      \begin{itemize}
        \item collections, itertools - collecting and looping over items
        \item math - mathematical functions
        \item warnings - issuing and supressing warnings
        \item os.path - OS-independent path/file-name manipulation
        \item datetime, time, calendar - working with dates and times
        \item ConfigParse - configuration file parsing
        \item optparse - command-line option parsing
        \item logging - controlling output
        \item ctypes - calling into libraries
      \end{itemize}
  \end{itemize}

\subsection{Configuration Files}
  \begin{itemize}
    \item The radar simulation software makes use of configuration files to
      control various radar operation parameters
    \item Old format read values from a file in fixed order (Text field present for user but not parsed)
    \item Made use of ConfigParse module from the standard library
    \item Provides flexible configuration files with support for sections and comments
    \item Simple API to open a configuration file and begin reading options
  \end{itemize}

  \lstinputlisting{oldconfig}
  \lstinputlisting{newconfig}
  \begin{itemize}
    \item Replaced brittle file format with something that is easy for users to understand
    \item Replaced brittle, unmaintainable code with something much easier to enhance
    \item Shrank code by 600 LOC
  \end{itemize}
  HUGE usability improvment.

\subsection{Logging}
  \begin{itemize}
    \item Console messages are the way the program communicates with the user
    \item However, the messages that are useful to a developer are not the
      same as what other users needs to see
    \item Logging libraries provide custom printing functions that allow fine-grained
      control of what messages are printed
    \item Python includes the {\bf logging} module that includes a raft of features:
    \begin{itemize}
      \item Control of message information (time, filename, line number, etc.)
      \item Different message commands for different levels (warning, info, debug, etc.)
      \item Different message handlers (file, screen, email?)
    \end{itemize}
  \end{itemize}

  \begin{itemize}
    \item Added 40 LOC to set up logging, replaced prints with logger.*
    \item Can optionally get detailed messages with a simple command line flag
    \item Can turn on some messages only when \emph{I} want them
    \item Can tell messages to log to a file
    \item No \#ifdefs or commenting/uncommenting prints
    \item Big improvements in usability for me as a developer and for other users
  \end{itemize}

\subsection{Command Line Parser}
  \lstset{language=Python}
  \begin{itemize}
    \item optparse module included in Python standard library
    \item Handle parsing of commandline into passed in arguments and options:

    \verb$radarsim -vvv -d -l run.log config/example.config$
    \item Programmatically add individual options
    \lstinputlisting[caption=]{optparse.py}
    \item Can also set default values for options
    \item Get a help display for free
  \end{itemize}


{\tiny
\begin{verbatim}
Usage: radarsim [options] configfiles

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -v, --verbose         Produce more verbose messages. Specify more than once
                        for more messages.
  -q, --quiet           Make output messages more quiet. Specify more than
                        once for less output.
  -d, --detailed        Use detailed logging messages.
  -l FILE, --log-output=FILE
                        Log output messages to FILE. Only error messages will
                        be displayed to the console.
  -L, --log-only        Used to specify that output only goes to logfile. Need
                        to also specify --log-output.
\end{verbatim}}

\subsection{Command Line Parser:Impacts}
  \begin{itemize}
    \item Increased code by 100 LOC
    \item However, old code was simplistic
    \item Those 100 lines of new code added support for:
    \begin{itemize}
      \item Controlling message verbosity
      \item Controlling other logger behavior
      \item Drastically improved help message
    \end{itemize}
  \end{itemize}
  Overall impact was a large increase in usability with minimal development effort.


In addition to the utility of the standard library, the syntax and features of Python
permit library developers to create more expressive interfaces than would be possible
in may other languages. Much of this stems from Python's dynamic nature.

NetCDF is a specific example of such a library. The available Python interfaces for creating
NetCDF files is vastly more simple than the reference C interface. Part of the reason for
simplicity is the available of a de facto standard array type from the NumPy library. NumPy
provides a mathmatical array type that handles memory allocation and provides array-based
mathematical operations. The other reason for the simplicity is again Python's dynamic nature.
As a self-describing, flexible file formats, the data types for different fields in NetCDF
files are not known a priori. Combined with the need to know types when compiling, this
leads to the creation of large amount of code (functions, data structures, etc.) to handle
the possible cases.  A dynamic language lends itself much more readily to such a flexible-typed
file format, and this shows in the difference in interfaces.


\section{NetCDF}
  \begin{itemize}
    \item Many packages:
    \begin{itemize}
      \item PyNIO - Part of NCAR's PyNGL package
      \item Scientific.IO.NetCDF
      \item pupynere (scipy.io.netcdf)
      \item netcdf4-python
    \end{itemize}
    \item But they all pretty much follow the same API
    \item Which is \emph{much} simpler than reading and writing NetCDF in C
  \end{itemize}

  \lstset{language=C}
  \begin{lstlisting}
    int nc_file, var_id, ndims;
    nc_open("Test_data.nc", NC_NOWRITE, &nc_file);
    nc_inq_varid(nc_file, "Temperature", &var_id);
    nc_inq_varndims(nc_file, var_id, &ndims);
    int* dims = malloc(ndims * sizeof(int));
    nc_inq_vardimid(nc_file, var_id, dims);
    size_t dim_len, total_size = 1;
    for(int i=0; i<ndims; ++i)
    {
        nc_inq_dimlen(nc_file, dims[i], &dim_len);
        total_size *= dim_len;
    }
    float* var = malloc(total_size * sizeof(float));
    nc_get_var_float(nc_file, var_id, var);
    free(dims); free(var);
    nc_close(nc_file);
  \end{lstlisting}

  \lstset{language=Python}
  \begin{lstlisting}
  from pupynere import netcdf_file
  nc = netcdf_file('Test_data.nc', 'r')

  temp_var = nc.variables('Temperature')

  print temp_var.units

  nc.close()
  \end{lstlisting}

\subsection{Python NetCDF API: Impacts}
  \begin{itemize}
    \item Rewrote I/O layer -- shrank by 800 LOC
    \item Better output metadata (units, time of run, etc.)
    \item Adding new input and output fields/attributes much simpler with Python
    \item As a consequence, the output files contain much more useful
      information for reproducing previous results
  \end{itemize}

\section{Modularity and Wrapping existing code}
\subsection{Wrapping code}
  \begin{itemize}
    \item Ctypes - wrap existing libraries
    \begin{itemize}
        \item Can express C structures in a python syntax
        \item Dynamically grab function names and specify calling types
        \item Can use pointer types to pass numpy arrays
    \end{itemize}
    \item F2Py - wrap and call fortran code from Python
    \item Cython - Generate C-code (and compiled library) from Python-like syntax
  \end{itemize}

\subsection{Modular Code Reuse}
  \begin{itemize}
    \item Needed T-Matrix calculations -> F77 Code
    \item Wrapped with F2Py to give a nice numpy interface for scattering calculations
    \item Used initially just for quick analyses of scattering effects
    \item Was able to re-use this module (which lives as a separate project)
    \item Re-use leads to better testing and fixing as opposed to separate code bases
  \end{itemize}

\section{Conclusion}
The use of Python enabled the rapid development of the additional required
functionality; total development time was approximately 3 months for a graduate
student working full-time. Through the use of Python's standard library, the required
features were added without a large increase in code size (and hence maintainance
burden).  In fact, porting to Python, in terms of lines of code, actually reduced
the size of the code base. The initial size of the code was 5400 lines of C code.
The final ported version has 2000 lines of Python and 2900 lines of C (not including
the separate library for scattering calculations).

Porting this software package to Python has demonstrated that Python posesses
many attributes that make it easier for developing than in traditional, statically
typed languages. Python's standard library offers many built-in facilities that
make accomplishing a task, like parsing a configuration file, a rapid endeavor.
Python's 3rd-party support for NetCDF files is a large improvement over the
support in C or FORTRAN.  The ability to use Python's ctypes library (or the
3rd part Cython package) to link to existing code allows one to keep
performance-critical sections of the code in a language like C, while permitting
rapid development in Python for the rest. This allows developers to use the best
tools for the job at hand and maximize their development time. For a scientist,
this can also mean spending less time developing code and more time applying
it to research problems.

%\subsection{Thanks and Questions}
%  Thanks to:
%  \begin{description}[Matplotlib]
%    \item[Python]{http://www.python.org}
%    \item[NumPy]{http://numpy.scipy.org}
%    \item[SciPy]{http://www.scipy.org}
%    \item[Matplotlib]{http://matplotlib.sourceforge.net}
%    \item[pupynere]{http://pypi.python.org/pypi/pupynere}
%  \end{description}
%  Questions?

\end{document}
